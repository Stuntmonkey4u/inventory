---
# Play 1: Collect forensic data from remote hosts

- name: Collect forensic inventory data
  hosts: all
  gather_facts: true # yaml[truthy]
  vars:
    collect_services_info: true
    collect_packages_info: true
    collect_docker_info: true
    collect_network_info: true
    collect_user_logs_info: true
    collect_system_info: true # For boot time and fs_usage
    collect_lynis_info: true
    collect_rkhunter_info: true
    collect_aide_info: false
    collect_process_info: true
    collect_privilege_info: true
    collect_persistence_info: true
  tasks:

    - name: Ensure temporary report directory exists on controller
      ansible.builtin.file:
        path: "{{ report_dir | default('/tmp/reports') }}"
        state: directory
        mode: '0755'
      delegate_to: localhost
      run_once: true
      become: false # Should not need root for /tmp

    - name: Ensure AIDE baseline directory exists on controller
      ansible.builtin.file:
        path: "{{ playbook_dir }}/aide_baselines"
        state: directory
        mode: '0755' # Controller user needs to write here
      delegate_to: localhost
      run_once: true
      # No become needed if playbook_dir is user-writable

    - name: Gather Service Information
      tags: services
      block:
        - name: Gather all system service statuses (for "All Services")
          ansible.builtin.command: "systemctl list-unit-files --type=service --no-pager" # Use command; systemd module is an option for deeper integration.
          register: services
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Gather verified running system services
          ansible.builtin.command: "systemctl list-units --type=service --state=running --no-pager --no-legend --plain" # systemd module is an option.
          register: running_services
          changed_when: false
          ignore_errors: true # yaml[truthy]
      when: collect_services_info

    - name: Gather Package Information
      tags: packages
      block:
        - name: Gather package facts
          ansible.builtin.package_facts:
          ignore_errors: true # yaml[truthy]

        - name: Get upgradable packages (apt systems)
          ansible.builtin.shell:
            cmd: "set -o pipefail && apt list --upgradable 2>/dev/null | grep -v 'Listing...'"
            executable: /bin/bash
          register: upgradable_packages
          changed_when: false
          when: ansible_pkg_mgr == 'apt'
          ignore_errors: true
      when: collect_packages_info

    - name: Gather Docker Information
      tags: docker
      block:
        - name: Check for Docker command
          ansible.builtin.command: command -v docker
          register: docker_cmd_check
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get Docker version
          ansible.builtin.command: docker --version
          register: docker_check
          when: docker_cmd_check.rc == 0
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get running Docker containers
          ansible.builtin.command: "docker ps --format '{{ '{{' }}.Names}}: {{ '{{' }}.Image}}'" # noqa jinja[invalid]
          register: docker_containers
          when: docker_cmd_check.rc == 0
          changed_when: false
          ignore_errors: true # yaml[truthy]
      when: collect_docker_info

    - name: Gather Network Information
      tags: network
      block:
        - name: Check for ss command
          ansible.builtin.command: command -v ss
          register: ss_cmd_check
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get listening ports with ss
          ansible.builtin.command: ss -tulnp
          register: listening_ports_ss
          when: ss_cmd_check.rc == 0
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Check for netstat command
          ansible.builtin.command: command -v netstat
          register: netstat_cmd_check
          when: ss_cmd_check.rc != 0 # Only check if ss is not available
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get listening ports with netstat
          ansible.builtin.command: netstat -tulnp
          register: listening_ports_netstat
          when:
            - ss_cmd_check.rc != 0
            - netstat_cmd_check.rc == 0
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Set listening_ports fact
          ansible.builtin.set_fact:
            listening_ports: "{{ listening_ports_ss if ss_cmd_check.rc == 0 else listening_ports_netstat }}"
          changed_when: false

        - name: Gather Firewall Information
          tags: firewall
          block:
            - name: Check for iptables command
              ansible.builtin.command: command -v iptables
              register: iptables_cmd_check
              changed_when: false
              ignore_errors: true # yaml[truthy]

            - name: Get iptables rules
              ansible.builtin.command: iptables -L -n -v
              register: firewall_rules_iptables
              when: iptables_cmd_check.rc == 0
              changed_when: false
              ignore_errors: true # yaml[truthy]

            - name: Check for ufw command
              ansible.builtin.command: command -v ufw
              register: ufw_cmd_check
              when: iptables_cmd_check.rc != 0 # Only check if iptables is not available
              changed_when: false
              ignore_errors: true # yaml[truthy]

            - name: Get ufw status
              ansible.builtin.command: ufw status
              register: firewall_rules_ufw
              when:
                - iptables_cmd_check.rc != 0
                - ufw_cmd_check.rc == 0
              changed_when: false
              ignore_errors: true # yaml[truthy]

            - name: Set firewall_rules fact
              ansible.builtin.set_fact:
                firewall_rules: "{{ firewall_rules_iptables if iptables_cmd_check.rc == 0 else firewall_rules_ufw }}"
              changed_when: false
      when: collect_network_info

    - name: Gather User and Log Information
      tags: user_logs
      block:
        - name: Get login history
          ansible.builtin.command: lastlog
          register: lastlog
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get root cron jobs
          ansible.builtin.command: crontab -l
          register: root_cron
          changed_when: false
          ignore_errors: true
      when: collect_user_logs_info

    - name: Gather System Information
      tags: system
      block:
        - name: Get boot time
          ansible.builtin.command: uptime -s
          register: boot_time
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get filesystem usage
          ansible.builtin.command: df -h
          register: fs_usage
          changed_when: false
          ignore_errors: true # yaml[truthy]
      when: collect_system_info

    - name: Gather Process and Network Analysis
      tags: process_network
      block:
        - name: Get full process list
          ansible.builtin.command: ps auxwww
          register: process_list
          changed_when: false
          ignore_errors: true

        - name: Install lsof
          ansible.builtin.package:
            name: lsof
            state: present
          register: lsof_install_result
          ignore_errors: true
          become: true

        - name: Get open files and connections
          ansible.builtin.command: lsof -n
          register: open_files
          when: lsof_install_result is not failed
          changed_when: false
          ignore_errors: true
      when: collect_process_info

    - name: Perform Security Scans (Lynis, Rkhunter)
      tags: security_scans
      block:
        - name: Ensure security scan tools are installed (lynis, rkhunter)
          ansible.builtin.package:
            name:
              - lynis
              - rkhunter
            state: present
          register: security_tools_install_result # We still register to potentially use details about install success/failure in status, though direct check is better
          ignore_errors: true # yaml[truthy]
          when: collect_lynis_info or collect_rkhunter_info
          become: true

        - name: Check if rkhunter is available
          ansible.builtin.command: command -v rkhunter
          register: rkhunter_exists
          changed_when: false
          ignore_errors: true # yaml[truthy]
          when: collect_rkhunter_info

        - name: Update rkhunter database (might require internet)
          ansible.builtin.command: rkhunter --update
          register: rkhunter_update_result
          changed_when: "'updated' in rkhunter_update_result.stdout | lower"
          ignore_errors: true # yaml[truthy]
          when:
            - collect_rkhunter_info
            - rkhunter_exists is defined and rkhunter_exists.rc == 0

        - name: Check if lynis is available
          ansible.builtin.command: command -v lynis
          register: lynis_exists
          changed_when: false
          ignore_errors: true # yaml[truthy]
          when: collect_lynis_info

        - name: Run Lynis Scan
          ansible.builtin.command: lynis audit system --quiet --no-colors
          register: lynis_scan_result
          changed_when: false
          ignore_errors: true # yaml[truthy]
          when:
            - collect_lynis_info
            - lynis_exists is defined and lynis_exists.rc == 0

        - name: Run Rkhunter Scan
          ansible.builtin.command: rkhunter --check --sk --nocolors
          register: rkhunter_scan_result
          changed_when: false
          ignore_errors: true # yaml[truthy]
          when:
            - collect_rkhunter_info
            - rkhunter_exists is defined and rkhunter_exists.rc == 0
      when: collect_lynis_info or collect_rkhunter_info

    - name: Gather User and Privilege Auditing
      tags: user_privilege
      block:
        - name: Get sudoers file content
          ansible.builtin.slurp:
            src: /etc/sudoers
          register: sudoers_file
          ignore_errors: true
          become: true

        - name: Find sudoers.d files
          ansible.builtin.find:
            paths: /etc/sudoers.d
            recurse: yes
          register: sudoers_d_files
          ignore_errors: true

        - name: Get content of sudoers.d files
          ansible.builtin.slurp:
            src: "{{ item.path }}"
          register: sudoers_d_content
          loop: "{{ sudoers_d_files.files | default([]) }}"
          ignore_errors: true
          become: true

        - name: Get all users
          ansible.builtin.getent:
            database: passwd
          register: all_users
          ignore_errors: true

        - name: Get all users cron jobs
          ansible.builtin.command: "crontab -l -u {{ item.key }}"
          register: user_cron_jobs
          loop: "{{ all_users.ansible_facts.getent_passwd | default({}) | dict2items }}"
          changed_when: false
          ignore_errors: true
          become: true

        - name: Check for existence of authorized_keys for all users
          ansible.builtin.stat:
            path: "{{ item.value[5] }}/.ssh/authorized_keys"
          register: ssh_keys_stat
          loop: "{{ all_users.ansible_facts.getent_passwd | default({}) | dict2items }}"
          loop_control:
            label: "{{ item.key }}"
          when: item.value[5] is defined and item.value[5].startswith('/home') and item.value[5] != '/home'
          become: true
          ignore_errors: true

        - name: Get all users SSH authorized keys
          ansible.builtin.slurp:
            src: "{{ item.item.value[5] }}/.ssh/authorized_keys"
          register: ssh_keys
          loop: "{{ ssh_keys_stat.results }}"
          loop_control:
            label: "{{ item.item.key }}"
          when: item.stat is defined and item.stat.exists and item.stat.isreg
          ignore_errors: true
          become: true
      when: collect_privilege_info

    - name: Gather Persistence Mechanisms
      tags: persistence
      block:
        - name: Get systemd timers
          ansible.builtin.command: systemctl list-timers
          register: systemd_timers
          changed_when: false
          ignore_errors: true
      when: collect_persistence_info

    - name: Perform AIDE File Integrity Check
      tags: aide
      block:
        - name: Install AIDE package
          ansible.builtin.package:
            name: aide
            state: present
          register: aide_install_result
          ignore_errors: true # yaml[truthy]
          become: true

        - name: Check if AIDE command is available
          ansible.builtin.shell: command -v aide
          register: aide_exists
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Set AIDE baseline path fact
          ansible.builtin.set_fact:
            aide_controller_baseline_path: "{{ playbook_dir }}/aide_baselines/{{ inventory_hostname }}.db.gz"
            aide_target_db_path: "/var/lib/aide/aide.db.gz"
          when: aide_exists.rc == 0

        - name: Check if AIDE baseline exists on controller
          ansible.builtin.stat:
            path: "{{ aide_controller_baseline_path }}"
          delegate_to: localhost
          register: aide_baseline_on_controller_stat
          when: aide_exists.rc == 0

        - name: Initialize AIDE and fetch baseline (if it does not exist on controller)
          when:
            - aide_exists.rc == 0
            - not aide_baseline_on_controller_stat.stat.exists
          block:
            - name: Ensure AIDE directory exists
              ansible.builtin.file:
                path: /var/lib/aide
                state: directory
                mode: '0755'
              become: true
            - name: Copy AIDE configuration file
              ansible.builtin.copy:
                src: aide.conf
                dest: /etc/aide/aide.conf
                mode: '0644'
              become: true
            - name: Initialize AIDE database on target
              ansible.builtin.command: aide --config /etc/aide/aide.conf --init
              register: aide_init_result
              changed_when: "'AIDE, version' in aide_init_result.stdout"
              ignore_errors: true # yaml[truthy]
              become: true

            - name: Move new AIDE database to active path
              ansible.builtin.command: mv /var/lib/aide/aide.db.new.gz {{ aide_target_db_path }}
              when: aide_init_result.rc == 0
              changed_when: true
              become: true

            - name: Fetch AIDE baseline from target to controller
              ansible.builtin.fetch:
                src: "{{ aide_target_db_path }}"
                dest: "{{ aide_controller_baseline_path }}"
                flat: true
                fail_on_missing: true
              when: aide_init_result.rc == 0
              become: true

            - name: Set fact that baseline was initialized
              ansible.builtin.set_fact:
                aide_baseline_initialized_this_run: true

        - name: Run AIDE Check (if baseline exists on controller)
          when:
            - aide_exists.rc == 0
            - aide_baseline_on_controller_stat.stat.exists
          block:
            - name: Ensure AIDE directory exists
              ansible.builtin.file:
                path: /var/lib/aide
                state: directory
                mode: '0755'
            - name: Copy AIDE baseline from controller to target
              ansible.builtin.copy:
                src: "{{ aide_controller_baseline_path }}"
                dest: "{{ aide_target_db_path }}"
                mode: '0600'

            - name: Run AIDE check against the baseline
              ansible.builtin.command: aide --check
              register: aide_check_result
              ignore_errors: true # AIDE exits >0 if changes are found.
              changed_when: false
      when: collect_aide_info

    - name: Set host-specific report data with sanitization
      ansible.builtin.set_fact:
        host_report_entry: >
          {{
          {
            inventory_hostname: {
              "hostname": ansible_hostname,
              "ip": (ansible_default_ipv4.address | default('N/A')),
              "os": ansible_distribution ~ " " ~ ansible_distribution_version,
              "uptime": (ansible_uptime_seconds | int // 3600) ~ " hours",
              "services_collected": "{{ collect_services_info }}",
              "verified_services": (running_services.stdout_lines | default([]) if collect_services_info else "Skipped"),
              "all_services": (services.stdout_lines | default([]) if collect_services_info else "Skipped"),
              "packages_collected": "{{ collect_packages_info }}",
              "packages": (ansible_facts.packages.keys() | list | default([]) if collect_packages_info else "Skipped"),
              "upgradable_packages": (upgradable_packages.stdout_lines | default([]) if collect_packages_info and ansible_pkg_mgr == 'apt' else ("N/A for this OS" if collect_packages_info else "Skipped")),
              "docker_collected": "{{ collect_docker_info }}",
              "docker": (docker_containers.stdout_lines | default([]) if collect_docker_info else "Skipped"),
              "network_collected": "{{ collect_network_info }}",
              "listening_ports": (listening_ports.stdout_lines | default([]) if collect_network_info else "Skipped"),
              "firewall_rules": (firewall_rules.stdout_lines | default([]) if collect_network_info else "Skipped"),
              "user_logs_collected": "{{ collect_user_logs_info }}",
              "login_history": (lastlog.stdout_lines | default([]) if collect_user_logs_info else "Skipped"),
              "cron_jobs": (root_cron.stdout_lines | default([]) if collect_user_logs_info else "Skipped"),
              "system_info_collected": "{{ collect_system_info }}",
              "boot_time": (boot_time.stdout | default('N/A') | regex_replace('\\[\\udc80-\\udcff]', '') if collect_system_info else "Skipped"),
              "filesystem": (fs_usage.stdout_lines | default([]) if collect_system_info else "Skipped"),

              "lynis_collected": "{{ collect_lynis_info }}",
              "lynis_status": (
                "Skipped" if not collect_lynis_info else
                ("Tool not found" if (lynis_exists is not defined or lynis_exists.rc != 0) else
                  ("Scan not run" if lynis_scan_result is not defined else
                   ("Error during run" if lynis_scan_result.failed or (lynis_scan_result.rc is defined and lynis_scan_result.rc != 0) else
                    ("Collected" if lynis_scan_result.stdout_lines | length > 0 else "No output")
                   )
                  )
                )
              ),
              "lynis_output": (lynis_scan_result.stdout_lines | default([]) if collect_lynis_info and lynis_exists is defined and lynis_exists.rc == 0 and lynis_scan_result is defined and not lynis_scan_result.failed and lynis_scan_result.rc is defined and lynis_scan_result.rc == 0 else []),

              "rkhunter_collected": "{{ collect_rkhunter_info }}",
              "rkhunter_status": (
                "Skipped" if not collect_rkhunter_info else
                ("Tool not found" if (rkhunter_exists is not defined or rkhunter_exists.rc != 0) else
                  ("Scan not run" if rkhunter_scan_result is not defined else
                   ("Error during run" if rkhunter_scan_result.failed or (rkhunter_scan_result.rc is defined and rkhunter_scan_result.rc != 0) else
                    ("Collected" if rkhunter_scan_result.stdout_lines | length > 0 else "No output")
                   )
                  )
                )
              ),
              "rkhunter_output": (rkhunter_scan_result.stdout_lines | default([]) if collect_rkhunter_info and rkhunter_exists is defined and rkhunter_exists.rc == 0 and rkhunter_scan_result is defined and not rkhunter_scan_result.failed and rkhunter_scan_result.rc is defined and rkhunter_scan_result.rc == 0 else []),

              "aide_collected": "{{ collect_aide_info }}",
              "aide_status": (
                "Skipped" if not collect_aide_info else
                ("Tool not found or install failed" if (aide_exists is not defined or aide_exists.rc != 0) or (aide_install_result is defined and aide_install_result.failed) else
                  ("Baseline initialized and fetched" if aide_baseline_initialized_this_run is defined and aide_baseline_initialized_this_run else
                    ("Baseline not found on controller (init failed or not attempted this run)" if not (aide_baseline_on_controller_stat is defined and aide_baseline_on_controller_stat.stat.exists is defined and aide_baseline_on_controller_stat.stat.exists) else
                      ("AIDE check task did not run (e.g. baseline copy failed or AIDE command issue)" if aide_check_result is not defined else
                        ("Error during AIDE check" if (aide_check_result.failed or aide_check_result.rc is not defined) else
                          ("No changes found" if aide_check_result.rc == 0 else "Changes found")
                        )
                      )
                    )
                  )
                )
              ),
              "aide_output": (aide_check_result.stdout_lines | default([]) if collect_aide_info and aide_check_result is defined else "Skipped"),

              "process_info_collected": "{{ collect_process_info }}",
              "process_list": (process_list.stdout_lines | default([]) if collect_process_info else "Skipped"),
              "open_files": (open_files.stdout_lines | default([]) if collect_process_info else "Skipped"),

              "privilege_info_collected": "{{ collect_privilege_info }}",
              "sudoers_file": (sudoers_file.content | b64decode | default('') if collect_privilege_info else "Skipped"),
              "sudoers_d_content": (sudoers_d_content.results | default([]) if collect_privilege_info else "Skipped"),
              "user_cron_jobs": (user_cron_jobs.results | default([]) if collect_privilege_info else "Skipped"),
              "ssh_keys": (ssh_keys.results | selectattr('skipped', 'undefined') | map(attribute='content') | map('b64decode') | list if collect_privilege_info else "Skipped"),

              "persistence_info_collected": "{{ collect_persistence_info }}",
              "systemd_timers": (systemd_timers.stdout_lines | default([]) if collect_persistence_info else "Skipped")
            }
          }
          }}
      changed_when: false

    - name: Write host report to temporary file
      ansible.builtin.copy:
        content: "{{ host_report_entry | to_nice_json }}"
        dest: "{{ report_dir | default('/tmp/reports') }}/{{ inventory_hostname }}_{{ ansible_date_time.iso8601_basic_short }}.report.json"
        mode: '0600'
      delegate_to: localhost
      become: false # No need to become root to write to a user-owned directory

# ----------------------------------------

# Play 2: Aggregate and generate the enhanced report

- name: Aggregate and generate combined enhanced report
  hosts: localhost
  connection: local
  gather_facts: true # yaml[truthy]
  tasks:

    - name: Find all temporary report files
      ansible.builtin.find:
        paths: "{{ report_dir | default('/tmp/reports') }}"
        patterns: "*.report.json"
      register: found_reports
      changed_when: false

    - name: Initialize combined report data
      ansible.builtin.set_fact:
        combined_report_data: {}
      changed_when: false

    - name: Merge host reports
      ansible.builtin.set_fact:
        combined_report_data: "{{ combined_report_data | combine(host_report) }}"
      vars: # key-order (vars often comes before module args or with set_fact, it's fine)
        host_report: "{{ lookup('file', item.path) | from_json }}"
      loop: "{{ found_reports.files }}"
      changed_when: false

    - name: Ensure reports directory exists on localhost
      ansible.builtin.file:
        path: "./reports"
        state: directory
        mode: '0755'
      become: false # yaml[truthy]

    - name: Write combined JSON report for reference
      ansible.builtin.copy:
        content: "{{ combined_report_data | to_nice_json }}"
        dest: "./reports/inventory_report_{{ ansible_date_time.iso8601 }}.json"
        mode: '0644' # risky-file-permissions
      become: false # yaml[truthy]

    - name: Write enhanced HTML report
      ansible.builtin.template:
        src: "templates/enhanced_report.html.j2"
        dest: "./reports/inventory_report_{{ ansible_date_time.date }}.html"
        mode: '0644' # risky-file-permissions
      vars:
        report_data: "{{ combined_report_data }}"
      become: false # yaml[truthy]

    - name: Cleanup old report files from temporary directory
      ansible.builtin.file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ found_reports.files }}"
      become: true # yaml[truthy]

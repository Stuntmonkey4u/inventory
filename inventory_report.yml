---
# Play 1: Collect forensic data from remote hosts

- name: Collect forensic inventory data
  hosts: all
  gather_facts: true # yaml[truthy]
  vars:
    collect_services_info: true
    collect_packages_info: true
    collect_docker_info: true
    collect_network_info: true
    collect_user_logs_info: true
    collect_system_info: true # For boot time and fs_usage
    collect_lynis_info: true
    collect_rkhunter_info: true
    collect_aide_info: true
  tasks:

    - name: Ensure temporary report directory exists on controller
      ansible.builtin.file:
        path: "{{ report_dir | default('/tmp/reports') }}"
        state: directory
        mode: '0755'
      delegate_to: localhost
      run_once: true
      become: true # Might be needed if default /tmp/reports needs root

    - name: Ensure AIDE baseline directory exists on controller
      ansible.builtin.file:
        path: "{{ playbook_dir }}/aide_baselines"
        state: directory
        mode: '0755' # Controller user needs to write here
      delegate_to: localhost
      run_once: true
      # No become needed if playbook_dir is user-writable

    - name: Gather Service Information
      tags: services
      block:
        - name: Gather all system service statuses (for "All Services")
          ansible.builtin.command: "systemctl list-unit-files --type=service --no-pager" # Use command; systemd module is an option for deeper integration.
          register: services
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Gather verified running system services
          ansible.builtin.command: "systemctl list-units --type=service --state=running --no-pager --no-legend --plain" # systemd module is an option.
          register: running_services
          changed_when: false
          ignore_errors: true # yaml[truthy]
      when: collect_services_info

    - name: Gather Package Information
      tags: packages
      block:
        - name: Gather package facts
          ansible.builtin.package_facts:
          ignore_errors: true # yaml[truthy]

        - name: Get upgradable packages (apt systems)
          ansible.builtin.shell:
            cmd: "set -o pipefail && apt list --upgradable | grep -v 'Listing...'" # risky-shell-pipe
            executable: /bin/bash
          register: upgradable_packages
          failed_when: >
            upgradable_packages.rc != 0 and
            'Listing...' not in upgradable_packages.stderr and
            'WARNING: apt does not have a stable CLI interface' not in upgradable_packages.stderr
          changed_when: false

        - name: Debug upgradable packages output
          ansible.builtin.debug:
            msg: |
              Upgradable packages rc: {{ upgradable_packages.rc }}
              Upgradable packages stderr: {{ upgradable_packages.stderr }}
              Upgradable packages stdout: {{ upgradable_packages.stdout }}
          when: upgradable_packages.stderr is defined and upgradable_packages.stderr != ""
      when: collect_packages_info

    - name: Gather Docker Information
      tags: docker
      block:
        - name: Check if Docker is installed
          ansible.builtin.shell: |
            if command -v docker >/dev/null 2>&1; then
              docker --version
              exit 0
            else
              exit 127
            fi
          register: docker_check
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get running Docker containers
          ansible.builtin.shell: "docker ps --format '{{ '{{' }}.Names}}: {{ '{{' }}.Image}}'" # noqa jinja[invalid] <- Linter struggles with Go template
          register: docker_containers
          when: docker_check.rc == 0
          changed_when: false
          ignore_errors: true # yaml[truthy]
      when: collect_docker_info

    - name: Gather Network Information
      tags: network
      block:
        - name: Get listening ports
          ansible.builtin.shell: |
            if command -v ss >/dev/null; then
              ss -tulnp
            elif command -v netstat >/dev/null; then
              netstat -tulnp
            else
              echo "No tool found to list ports"
            fi
          register: listening_ports
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Gather Firewall Information
          tags: firewall
          block: # This inner block for a single task is fine
            - name: Get firewall rules (Check for iptables or ufw)
              ansible.builtin.shell: |
                if command -v iptables > /dev/null; then
                  iptables -L -n -v
                elif command -v ufw > /dev/null; then
                  ufw status
                else
                  echo "No iptables or ufw found"
                fi
              register: firewall_rules
              changed_when: false
              ignore_errors: true # yaml[truthy]
      when: collect_network_info # This 'when' applies to the entire outer block

    - name: Gather User and Log Information
      tags: user_logs
      block:
        - name: Get login history
          ansible.builtin.shell: |
            if command -v lastlog > /dev/null; then
              lastlog
            else
              echo "lastlog command not found"
            fi
          register: lastlog
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get root cron jobs
          ansible.builtin.shell: "crontab -l || echo 'no crontab for root'" # Needs shell due to ||
          register: root_cron
          changed_when: false
          ignore_errors: true # yaml[truthy]
      when: collect_user_logs_info

    - name: Gather System Information
      tags: system
      block:
        - name: Get boot time
          ansible.builtin.command: uptime -s # Changed from shell
          register: boot_time
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Get filesystem usage
          ansible.builtin.command: df -h # Changed from shell
          register: fs_usage
          changed_when: false
          ignore_errors: true # yaml[truthy]
      when: collect_system_info

    - name: Perform Security Scans (Lynis, Rkhunter)
      tags: security_scans
      block:
        - name: Ensure security scan tools are installed (lynis, rkhunter)
          ansible.builtin.package:
            name:
              - lynis
              - rkhunter
            state: present
          register: security_tools_install_result # We still register to potentially use details about install success/failure in status, though direct check is better
          ignore_errors: true # yaml[truthy]
          when: collect_lynis_info or collect_rkhunter_info

        - name: Check if rkhunter is available
          ansible.builtin.command: command -v rkhunter
          register: rkhunter_exists
          changed_when: false
          ignore_errors: true # yaml[truthy]
          when: collect_rkhunter_info

        - name: Update rkhunter database (might require internet)
          ansible.builtin.command: rkhunter --update
          register: rkhunter_update_result
          changed_when: "'updated' in rkhunter_update_result.stdout | lower"
          ignore_errors: true # yaml[truthy]
          when:
            - collect_rkhunter_info
            - rkhunter_exists is defined and rkhunter_exists.rc == 0

        - name: Check if lynis is available
          ansible.builtin.command: command -v lynis
          register: lynis_exists
          changed_when: false
          ignore_errors: true # yaml[truthy]
          when: collect_lynis_info

        - name: Run Lynis Scan
          ansible.builtin.command: lynis audit system --quiet --no-colors
          register: lynis_scan_result
          changed_when: false
          ignore_errors: true # yaml[truthy]
          when:
            - collect_lynis_info
            - lynis_exists is defined and lynis_exists.rc == 0

        - name: Run Rkhunter Scan
          ansible.builtin.command: rkhunter --check --sk --nocolors
          register: rkhunter_scan_result
          changed_when: false
          ignore_errors: true # yaml[truthy]
          when:
            - collect_rkhunter_info
            - rkhunter_exists is defined and rkhunter_exists.rc == 0
      when: collect_lynis_info or collect_rkhunter_info

    - name: Perform AIDE File Integrity Check
      tags: aide
      block:
        - name: Install AIDE package
          ansible.builtin.package:
            name: aide # Common name, might need 'aide-common' or platform specific adjustments
            state: present
          register: aide_install_result
          ignore_errors: true # yaml[truthy]

        - name: Check if AIDE command is available
          ansible.builtin.command: command -v aide
          register: aide_exists
          changed_when: false
          ignore_errors: true # yaml[truthy]

        - name: Set AIDE baseline path facts
          ansible.builtin.set_fact:
            aide_controller_baseline_path: "{{ playbook_dir }}/aide_baselines/{{ inventory_hostname }}.db.gz"
            aide_target_temp_new_db_path: "/var/lib/aide/aide.db.new.gz" # Default AIDE output
            aide_target_active_db_path: "/var/lib/aide/aide.db.gz" # Standard operational path
          when: aide_exists.rc == 0

        - name: Check if AIDE baseline exists on controller for this host
          ansible.builtin.stat:
            path: "{{ aide_controller_baseline_path }}"
          delegate_to: localhost
          register: aide_baseline_on_controller_stat
          when: aide_exists.rc == 0

        - name: Initialize AIDE and fetch baseline (if not on controller)
          block:
            - name: Ensure AIDE database directory exists on target
              ansible.builtin.file:
                path: "/var/lib/aide"
                state: directory
                mode: '0755' # Or more restrictive as AIDE recommends

            - name: Initialize AIDE database on target
              ansible.builtin.command: aide --init # or aideinit, depending on distro version of aide
              register: aide_init_result
              changed_when: false # Success (rc=0) implies the new DB is created at aide_target_temp_new_db_path
              ignore_errors: true # yaml[truthy] (to capture status later)

            - name: Rename newly initialized AIDE database
              ansible.builtin.command: "mv {{ aide_target_temp_new_db_path }} {{ aide_target_active_db_path }}"
              when: aide_init_result is defined and aide_init_result.rc == 0
              register: aide_rename_result
              changed_when: aide_rename_result.rc == 0
              ignore_errors: true # yaml[truthy]

            - name: Fetch AIDE baseline from target to controller
              ansible.builtin.fetch:
                src: "{{ aide_target_active_db_path }}" # e.g. /var/lib/aide/aide.db.gz
                dest: "{{ aide_controller_baseline_path }}" # e.g. ./aide_baselines/hostname.db.gz
                flat: yes # Ensures dest is treated as a file path
                fail_on_missing: yes
              when: aide_rename_result is defined and aide_rename_result.rc == 0
              register: aide_fetch_result

            - name: Set fact that baseline was initialized
              ansible.builtin.set_fact:
                aide_baseline_initialized_this_run: true
              when: aide_fetch_result is defined and not aide_fetch_result.failed

          when:
            - aide_exists.rc == 0
            - aide_baseline_on_controller_stat.stat.exists is defined and not aide_baseline_on_controller_stat.stat.exists
            - aide_install_result is defined and not aide_install_result.failed # Ensure install didn't grossly fail

        - name: Run AIDE Check (if baseline exists on controller)
          block:
            - name: Ensure AIDE database directory exists on target (again, for this path)
              ansible.builtin.file:
                path: "/var/lib/aide"
                state: directory
                mode: '0755'

            - name: Copy AIDE baseline from controller to target
              ansible.builtin.copy:
                src: "{{ aide_controller_baseline_path }}"
                dest: "{{ aide_target_active_db_path }}"
                mode: '0600' # AIDE dbs should be protected
              register: aide_copy_to_target_result

            - name: Run AIDE check against the copied baseline
              ansible.builtin.command: aide --check
              register: aide_check_result
              ignore_errors: true # AIDE exits >0 if changes are found or errors occur.
              changed_when: false # This task only reads data.
              when: aide_copy_to_target_result is defined and not aide_copy_to_target_result.failed

          when:
            - aide_exists.rc == 0
            - aide_baseline_on_controller_stat.stat.exists is defined and aide_baseline_on_controller_stat.stat.exists
            - aide_install_result is defined and not aide_install_result.failed

      when: collect_aide_info

    - name: Set host-specific report data with sanitization
      ansible.builtin.set_fact:
        host_report_entry: >
          {{
          {
            inventory_hostname: {
              "hostname": ansible_hostname,
              "ip": (ansible_default_ipv4.address | default('N/A')),
              "os": ansible_distribution ~ " " ~ ansible_distribution_version,
              "uptime": (ansible_uptime_seconds | int // 3600) ~ " hours",
              "services_collected": "{{ collect_services_info }}",
              "verified_services": (running_services.stdout_lines | default([]) if collect_services_info else "Skipped"),
              "all_services": (services.stdout_lines | default([]) if collect_services_info else "Skipped"),
              "packages_collected": "{{ collect_packages_info }}",
              "packages": (ansible_facts.packages.keys() | list | default([]) if collect_packages_info else "Skipped"),
              "upgradable_packages": (upgradable_packages.stdout_lines | default([]) if collect_packages_info else "Skipped"),
              "docker_collected": "{{ collect_docker_info }}",
              "docker": (docker_containers.stdout_lines | default([]) if collect_docker_info else "Skipped"),
              "network_collected": "{{ collect_network_info }}",
              "listening_ports": (listening_ports.stdout_lines | default([]) if collect_network_info else "Skipped"),
              "firewall_rules": (firewall_rules.stdout_lines | default([]) if collect_network_info else "Skipped"),
              "user_logs_collected": "{{ collect_user_logs_info }}",
              "login_history": (lastlog.stdout_lines | default([]) if collect_user_logs_info else "Skipped"),
              "cron_jobs": (root_cron.stdout_lines | default([]) if collect_user_logs_info else "Skipped"),
              "system_info_collected": "{{ collect_system_info }}",
              "boot_time": (boot_time.stdout | default('N/A') | regex_replace('\\[\\udc80-\\udcff]', '') if collect_system_info else "Skipped"),
              "filesystem": (fs_usage.stdout_lines | default([]) if collect_system_info else "Skipped"),

              "lynis_collected": "{{ collect_lynis_info }}",
              "lynis_status": (
                "Skipped" if not collect_lynis_info else
                ("Tool not found" if (lynis_exists is not defined or lynis_exists.rc != 0) else
                  ("Scan not run" if lynis_scan_result is not defined else # Should not happen if lynis_exists.rc == 0
                   ("Error during run" if lynis_scan_result.failed or (lynis_scan_result.rc is defined and lynis_scan_result.rc != 0) else
                    ("Collected" if lynis_scan_result.stdout_lines | length > 0 else "No output")
                   )
                  )
                )
              ),
              "lynis_output": (lynis_scan_result.stdout_lines | default([]) if collect_lynis_info and lynis_exists is defined and lynis_exists.rc == 0 and lynis_scan_result is defined and not lynis_scan_result.failed and lynis_scan_result.rc is defined and lynis_scan_result.rc == 0 else []),

              "rkhunter_collected": "{{ collect_rkhunter_info }}",
              "rkhunter_status": (
                "Skipped" if not collect_rkhunter_info else
                ("Tool not found" if (rkhunter_exists is not defined or rkhunter_exists.rc != 0) else
                  ("Scan not run" if rkhunter_scan_result is not defined else # Should not happen if rkhunter_exists.rc == 0
                   ("Error during run" if rkhunter_scan_result.failed or (rkhunter_scan_result.rc is defined and rkhunter_scan_result.rc != 0) else
                    ("Collected" if rkhunter_scan_result.stdout_lines | length > 0 else "No output")
                   )
                  )
                )
              ),
              "rkhunter_output": (rkhunter_scan_result.stdout_lines | default([]) if collect_rkhunter_info and rkhunter_exists is defined and rkhunter_exists.rc == 0 and rkhunter_scan_result is defined and not rkhunter_scan_result.failed and rkhunter_scan_result.rc is defined and rkhunter_scan_result.rc == 0 else []),

              "aide_collected": "{{ collect_aide_info }}",
              "aide_status": (
                "Skipped" if not collect_aide_info else
                ("Tool not found or install failed" if (aide_exists is not defined or aide_exists.rc != 0) or (aide_install_result is defined and aide_install_result.failed) else
                  ("Baseline initialized and fetched" if aide_baseline_initialized_this_run is defined and aide_baseline_initialized_this_run else
                    ("Baseline not found on controller (init failed or not attempted this run)" if not (aide_baseline_on_controller_stat is defined and aide_baseline_on_controller_stat.stat.exists is defined and aide_baseline_on_controller_stat.stat.exists) else
                      ("AIDE check task did not run (e.g. baseline copy failed or AIDE command issue)" if aide_check_result is not defined else
                        ("Error during AIDE check" if (aide_check_result.failed or aide_check_result.rc is not defined) else # .failed is true if module has critical error
                          ("No changes found" if aide_check_result.rc == 0 else "Changes found") # Any positive RC means changes
                        )
                      )
                    )
                  )
                )
              ),
              "aide_output": (
                aide_check_result.stdout_lines | default([]) if collect_aide_info and aide_check_result is defined and aide_check_result.rc is defined else
                (["Baseline initialized, no check performed on this run."] if aide_baseline_initialized_this_run is defined and aide_baseline_initialized_this_run else
                  ["AIDE data not available due to previous errors or status."] # Fallback message
                )
              )
            }
          }
          }}
      changed_when: false

    - name: Write host report to temporary file
      ansible.builtin.copy:
        content: "{{ host_report_entry | to_nice_json }}"
        dest: "{{ report_dir | default('/tmp/reports') }}/{{ inventory_hostname }}_{{ ansible_date_time.iso8601_basic_short }}.report.json"
        mode: '0600' # risky-file-permissions
      delegate_to: localhost
      become: true # yaml[truthy]

# ----------------------------------------

# Play 2: Aggregate and generate the enhanced report

- name: Aggregate and generate combined enhanced report
  hosts: localhost
  connection: local
  gather_facts: true # yaml[truthy]
  tasks:

    - name: Find all temporary report files
      ansible.builtin.find:
        paths: "{{ report_dir | default('/tmp/reports') }}"
        patterns: "*.report.json"
      register: found_reports
      changed_when: false

    - name: Initialize combined report data
      ansible.builtin.set_fact:
        combined_report_data: {}
      changed_when: false

    - name: Merge host reports
      ansible.builtin.set_fact:
        combined_report_data: "{{ combined_report_data | combine(host_report) }}"
      vars: # key-order (vars often comes before module args or with set_fact, it's fine)
        host_report: "{{ lookup('file', item.path) | from_json }}"
      loop: "{{ found_reports.files }}"
      changed_when: false

    - name: Ensure reports directory exists on localhost
      ansible.builtin.file:
        path: "./reports"
        state: directory
        mode: '0755'
      become: false # yaml[truthy]

    - name: Write combined JSON report for reference
      ansible.builtin.copy:
        content: "{{ combined_report_data | to_nice_json }}"
        dest: "./reports/inventory_report_{{ ansible_date_time.iso8601 }}.json"
        mode: '0644' # risky-file-permissions
      become: false # yaml[truthy]

    - name: Write enhanced HTML report
      ansible.builtin.template:
        src: "templates/enhanced_report.html.j2"
        dest: "./reports/inventory_report_{{ ansible_date_time.date }}.html"
        mode: '0644' # risky-file-permissions
      vars:
        report_data: "{{ combined_report_data }}"
      become: false # yaml[truthy]

    - name: Cleanup old report files from temporary directory
      ansible.builtin.file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ found_reports.files }}"
      become: true # yaml[truthy]
